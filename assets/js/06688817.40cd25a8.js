"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[203],{419:(e,r,n)=>{n.r(r),n.d(r,{contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var t=n(8168),a=(n(6540),n(5680));const s={id:"best-practices",title:"Best Practices",slug:"/best-practices"},i=void 0,o={unversionedId:"best-practices",id:"best-practices",title:"Best Practices",description:"This document gathers best practices for leveraging the Sealed Monad pattern in your Scala applications. By following these guidelines, you'll create domain\u2010rich, type\u2010safe code that communicates intent clearly and minimizes runtime surprises.",source:"@site/../docs/best-practices.md",sourceDirName:".",slug:"/best-practices",permalink:"/sealed-monad/best-practices",editUrl:"https://github.com/theiterators/sealed-monad/tree/master/docs/../docs/best-practices.md",tags:[],version:"current",frontMatter:{id:"best-practices",title:"Best Practices",slug:"/best-practices"},sidebar:"docs",previous:{title:"API Reference",permalink:"/sealed-monad/api-reference"},next:{title:"Comparison with Other Approaches",permalink:"/sealed-monad/comparison"}},l=[{value:"1. Designing Your ADTs",id:"1-designing-your-adts",children:[{value:"\u2705 Create Specific, Descriptive Response Types",id:"-create-specific-descriptive-response-types",children:[],level:3},{value:"\u274c Avoid Generic Error Types",id:"-avoid-generic-error-types",children:[],level:3},{value:"\u2705 Model Domain-Specific Edge Cases",id:"-model-domain-specific-edge-cases",children:[],level:3}],level:2},{value:"2. Structuring Your Code",id:"2-structuring-your-code",children:[{value:"\u2705 Separate High-Level Flow from Implementation Details",id:"-separate-high-level-flow-from-implementation-details",children:[],level:3},{value:"\u274c Don&#39;t: Expose Sealed Monad in Public Interfaces",id:"-dont-expose-sealed-monad-in-public-interfaces",children:[],level:3},{value:"\u274c Don&#39;t: Mix Business Logic with Technical Details",id:"-dont-mix-business-logic-with-technical-details",children:[],level:3},{value:"\u2705 Use Method Names as Documentation",id:"-use-method-names-as-documentation",children:[],level:3}],level:2},{value:"3. Working with Options and Either",id:"3-working-with-options-and-either",children:[{value:"\u2705 Use valueOr for Option Extraction",id:"-use-valueor-for-option-extraction",children:[],level:3},{value:"\u2705 Chain Validations Fluently",id:"-chain-validations-fluently",children:[],level:3},{value:"\u2705 Use ensure for Conditional Validation",id:"-use-ensure-for-conditional-validation",children:[],level:3},{value:"\u2705 Use attempt for Complex Transformations",id:"-use-attempt-for-complex-transformations",children:[],level:3}],level:2},{value:"4. Side Effects and Debugging",id:"4-side-effects-and-debugging",children:[{value:"\u2705 Use tap for Debugging and Logging",id:"-use-tap-for-debugging-and-logging",children:[],level:3},{value:"\u2705 Use valueOrF, ensureF, attemptF for Logging with Cats Effect",id:"-use-valueorf-ensuref-attemptf-for-logging-with-cats-effect",children:[],level:3},{value:"\u2705 Use inspect for Comprehensive Logging",id:"-use-inspect-for-comprehensive-logging",children:[],level:3},{value:"\u2705 Use flatTap for Effectful Side Operations",id:"-use-flattap-for-effectful-side-operations",children:[],level:3}],level:2},{value:"5. Testing Strategies",id:"5-testing-strategies",children:[{value:"\u2705 Test All Possible Outcomes",id:"-test-all-possible-outcomes",children:[],level:3},{value:"\u2705 Test Helper Methods Independently",id:"-test-helper-methods-independently",children:[],level:3}],level:2},{value:"6. Common Pitfalls and How to Avoid Them",id:"6-common-pitfalls-and-how-to-avoid-them",children:[{value:"\u274c Don&#39;t: Forget to call .run",id:"-dont-forget-to-call-run",children:[],level:3},{value:"\u274c Don&#39;t: Mix Monad Transformers with Sealed Monad",id:"-dont-mix-monad-transformers-with-sealed-monad",children:[],level:3},{value:"\u274c Don&#39;t: Use overly complex transformations",id:"-dont-use-overly-complex-transformations",children:[],level:3}],level:2},{value:"7. Migration Strategies",id:"7-migration-strategies",children:[{value:"Gradual Adoption",id:"gradual-adoption",children:[],level:3},{value:"Example Refactoring Path",id:"example-refactoring-path",children:[],level:3}],level:2},{value:"8. Real-World Example: API Service",id:"8-real-world-example-api-service",children:[],level:2}],d={toc:l},c="wrapper";function u(e){let{components:r,...n}=e;return(0,a.yg)(c,(0,t.A)({},d,n,{components:r,mdxType:"MDXLayout"}),(0,a.yg)("p",null,"This document gathers best practices for leveraging the Sealed Monad pattern in your Scala applications. By following these guidelines, you'll create domain\u2010rich, type\u2010safe code that communicates intent clearly and minimizes runtime surprises."),(0,a.yg)("h2",{id:"1-designing-your-adts"},"1. Designing Your ADTs"),(0,a.yg)("p",null,"The foundation of effective Sealed Monad usage is a well-designed ADT (Algebraic Data Type) for operation results."),(0,a.yg)("h3",{id:"-create-specific-descriptive-response-types"},"\u2705 Create Specific, Descriptive Response Types"),(0,a.yg)("p",null,"Design ADTs that capture all possible outcomes of an operation clearly:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait UserRegistrationResult\nobject UserRegistrationResult {\n  final case class Success(userId: String) extends UserRegistrationResult\n  case object EmailAlreadyExists extends UserRegistrationResult\n  case object InvalidEmail extends UserRegistrationResult\n  case object PasswordTooWeak extends UserRegistrationResult\n  case object UsernameInvalid extends UserRegistrationResult\n}\n")),(0,a.yg)("h3",{id:"-avoid-generic-error-types"},"\u274c Avoid Generic Error Types"),(0,a.yg)("p",null,"Avoid overly general result types that hide the specifics of different outcomes:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// Too generic - avoid this\nsealed trait Result\nobject Result {\n  case class Success(data: Any) extends Result\n  case class Error(message: String) extends Result\n}\n")),(0,a.yg)("h3",{id:"-model-domain-specific-edge-cases"},"\u2705 Model Domain-Specific Edge Cases"),(0,a.yg)("p",null,"Include edge cases that are meaningful in your domain:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait PaymentResult\nobject PaymentResult {\n  final case class Success(transactionId: String) extends PaymentResult\n  case object InsufficientFunds extends PaymentResult\n  case object CardDeclined extends PaymentResult\n  case object PaymentMethodExpired extends PaymentResult\n  case object FraudDetected extends PaymentResult  // Domain-specific case\n  case object ProcessorUnavailable extends PaymentResult\n}\n")),(0,a.yg)("h2",{id:"2-structuring-your-code"},"2. Structuring Your Code"),(0,a.yg)("p",null,"The way you organize your code impacts its readability and maintainability."),(0,a.yg)("h3",{id:"-separate-high-level-flow-from-implementation-details"},"\u2705 Separate High-Level Flow from Implementation Details"),(0,a.yg)("p",null,"Create a clear hierarchical structure with high-level flows and focused helper methods:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'import pl.iterators.sealedmonad.syntax._\nimport pl.iterators.sealedmonad.Sealed\nimport cats.effect.IO\n\nclass OrderService(\n  userRepository: UserRepository,\n  productRepository: ProductRepository,\n  paymentService: PaymentService,\n  orderRepository: OrderRepository\n) {\n  \n  // High-level flow - clear and concise\n  def processOrder(userId: String, items: List[OrderItem]): IO[OrderResult] = {\n    (for {\n      user     <- findAndValidateUser(userId)\n      products <- validateProductsAvailability(items)\n      payment  <- processPayment(user, products)\n      order    <- createOrder(user, products, payment)\n    } yield OrderResult.Success(order.id)).run\n  }\n  \n  // Mid-level methods with focused responsibilities\n  private def findAndValidateUser(userId: String): Sealed[IO, User, OrderResult] = {\n    // Implementation details here\n    userRepository.findById(userId)\n      .valueOr[OrderResult](OrderResult.UserNotFound)\n      .ensure(user => user.isActive, OrderResult.UserInactive)\n  }\n  \n  private def validateProductsAvailability(items: List[OrderItem]): Sealed[IO, List[Product], OrderResult] = {\n    // Implementation details here\n    items.traverse { item =>\n      productRepository.findById(item.productId)\n        .valueOr[OrderResult](OrderResult.ProductNotFound(item.productId))\n        .ensure(p => p.stock >= item.quantity, OrderResult.InsufficientStock(item.productId))\n    }.seal\n  }\n  \n  private def processPayment(user: User, products: List[Product]): Sealed[IO, String, OrderResult] = {\n    // Implementation details here\n    val amount = calculateTotal(products)\n    paymentService.processPayment(user.id, amount)\n      .attempt {\n        case Right(transactionId) => Right(transactionId)\n        case Left(PaymentError.InsufficientFunds) => Left(OrderResult.PaymentFailed("Insufficient funds"))\n        case Left(PaymentError.CardDeclined) => Left(OrderResult.PaymentFailed("Card declined"))\n        case Left(_) => Left(OrderResult.PaymentFailed("Unknown payment error"))\n      }\n  }\n  \n  private def createOrder(user: User, products: List[Product], paymentId: String): Sealed[IO, Order, OrderResult] = {\n    // Implementation details here\n    orderRepository.create(user.id, products.map(p => OrderItem(p.id, 1)), paymentId).seal\n  }\n  \n  private def calculateTotal(products: List[Product]): BigDecimal = \n    products.map(_.price).sum\n}\n')),(0,a.yg)("h3",{id:"-dont-expose-sealed-monad-in-public-interfaces"},"\u274c Don't: Expose Sealed Monad in Public Interfaces"),(0,a.yg)("p",null,"Sealed Monad should never be exposed in the public interface of your module or service. It's designed for internal processing and error handling only."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// \u274c DON'T expose Sealed Monad in your public API\ndef create(auth: AuthContext, orgId: OrganizationId): Sealed[IO, Roadmap, RoadmapCreateResult]\n\n// \u2705 DO return the effect type with your ADT directly\ndef create(auth: AuthContext, orgId: OrganizationId): IO[RoadmapCreateResult]\n")),(0,a.yg)("p",null,"In a real service implementation, keep Sealed Monad internal:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"class RoadmapService {\n  // Define your Step type alias for better readability\n  private type Step[A] = Sealed[IO, A, RoadmapCreateResult]\n  \n  // Public interface returns IO[Result], not Sealed[IO, _, _]\n  def create(\n    auth: AuthContext, \n    orgId: OrganizationId,\n    request: RoadmapCreateRequest\n  ): IO[RoadmapCreateResult] =\n    (for {\n      _            <- checkAccessToOrganization(auth, orgId)\n      organization <- findOrganization(orgId)\n      roadmap      <- createRoadmap(organization, auth.id, request)\n    } yield RoadmapCreateResult.Created(roadmap)).run\n    \n  // Private methods use the Step type alias\n  private def checkAccessToOrganization(auth: AuthContext, id: OrganizationId): Sealed[IO, Boolean, RoadmapCreateResult] = ...\n  private def findOrganization(id: OrganizationId): Sealed[IO, Organization, RoadmapCreateResult] = ...\n  private def createRoadmap(org: Organization, userId: UserId, request: RoadmapCreateRequest): Sealed[IO, Roadmap, RoadmapCreateResult] = ...\n}\n")),(0,a.yg)("p",null,"By keeping Sealed Monad as an implementation detail, you maintain cleaner module boundaries and avoid leaking implementation details to your API consumers."),(0,a.yg)("h3",{id:"-dont-mix-business-logic-with-technical-details"},"\u274c Don't: Mix Business Logic with Technical Details"),(0,a.yg)("p",null,"Avoid mixing different levels of abstraction:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// Too much detail in the main flow - avoid this\ndef processOrder(orderId: String): IO[OrderResult] = {\n  (for {\n    orderOpt <- orderRepository.findById(orderId).seal\n    order <- orderOpt.valueOr(OrderResult.NotFound)\n    _ <- order.pure[IO].ensure(!_.isExpired, OrderResult.Expired)\n    _ <- paymentService.processPayment(order.total).ensure(_.isSuccessful, OrderResult.PaymentFailed)\n    _ <- emailService.sendConfirmation(order.userId, order.id).attempt {\n      case Right(_) => Right(())\n      case Left(_) => Left(OrderResult.EmailFailed)\n    }\n    tracking <- shippingService.ship(order).seal\n  } yield OrderResult.Success(tracking)).run\n}\n")),(0,a.yg)("h3",{id:"-use-method-names-as-documentation"},"\u2705 Use Method Names as Documentation"),(0,a.yg)("p",null,"Choose method names that describe business operations clearly:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"def registerUser(request: RegisterRequest): IO[RegisterResponse] = {\n  (for {\n    email     <- validateEmail(request.email)\n    password  <- validatePassword(request.password)\n    user      <- createUserAccount(email, password)\n    _         <- sendWelcomeEmail(user)\n  } yield RegisterResponse.Success(user.id)).run\n}\n")),(0,a.yg)("h2",{id:"3-working-with-options-and-either"},"3. Working with Options and Either"),(0,a.yg)("p",null,"Sealed Monad provides elegant ways to work with Option and Either types."),(0,a.yg)("h3",{id:"-use-valueor-for-option-extraction"},"\u2705 Use valueOr for Option Extraction"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// Find a user by ID or return NotFound\nuserRepository.findById(userId)  // IO[Option[User]]\n  .valueOr[UserResponse](UserResponse.NotFound)  // Sealed[IO, User, UserResponse]\n")),(0,a.yg)("h3",{id:"-chain-validations-fluently"},"\u2705 Chain Validations Fluently"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// Multiple validations in sequence\nuserRepository.findById(userId)\n  .valueOr[UserResponse](UserResponse.NotFound)  // If user doesn't exist\n  .ensure(!_.archived, UserResponse.AccountDeleted)  // If account is deleted\n  .ensure(_.isActive, UserResponse.AccountInactive)  // If account isn't active\n")),(0,a.yg)("h3",{id:"-use-ensure-for-conditional-validation"},"\u2705 Use ensure for Conditional Validation"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// Validate a product's availability\nproduct.pure[IO]\n  .ensure(_.inStock, ProductResponse.OutOfStock)\n  .ensure(_.price <= maxPrice, ProductResponse.PriceExceedsLimit)\n")),(0,a.yg)("h3",{id:"-use-attempt-for-complex-transformations"},"\u2705 Use attempt for Complex Transformations"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// Handle different validation errors differently\nvalidateAddress(address).attempt {\n  case Right(validatedAddress) => Right(validatedAddress)\n  case Left(AddressError.InvalidZipCode) => Left(UserResponse.InvalidZipCode)\n  case Left(AddressError.UnknownCity) => Left(UserResponse.UnknownCity)\n  case Left(_) => Left(UserResponse.InvalidAddress)\n}\n")),(0,a.yg)("h2",{id:"4-side-effects-and-debugging"},"4. Side Effects and Debugging"),(0,a.yg)("p",null,"Sealed Monad provides several operators for handling side effects without disrupting your main computation."),(0,a.yg)("h3",{id:"-use-tap-for-debugging-and-logging"},"\u2705 Use tap for Debugging and Logging"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'def processOrder(orderId: String): IO[OrderResponse] = {\n  (for {\n    order <- findOrder(orderId)\n      .tap(order => logger.debug(s"Found order: $order"))\n    payment <- processPayment(order)\n      .tap(payment => logger.info(s"Payment processed: ${payment.id}"))\n  } yield OrderResponse.Success(order.id)).run\n}\n')),(0,a.yg)("h3",{id:"-use-valueorf-ensuref-attemptf-for-logging-with-cats-effect"},"\u2705 Use valueOrF, ensureF, attemptF for Logging with Cats Effect"),(0,a.yg)("p",null,"The ",(0,a.yg)("strong",{parentName:"p"},"valueOrF")," operator extends the valueOr pattern with effectful error handling. Here, when a job can't be found, we log the error before returning the failure case. This allows for better observability while preserving your typed error channel."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'private def findJob(jobName: String): Step[Job] =\n  jobService.findJob(jobName)\n    .valueOrF(Logger[IO].error(s"Unable to find job $jobName").as(JobResult.JobNotFound))\n')),(0,a.yg)("p",null,"The ",(0,a.yg)("strong",{parentName:"p"},"ensureF")," operator combines validation with effectful error handling. In this example, we ensure the query results are non-empty, and if they aren't, we log an error message before returning the appropriate domain error. This pattern is perfect when you need to validate results and provide context about the failure."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'private def listJobs(filters: Seq[JobFilter]): JobStep[Seq[Job]] =\n  jobRepository\n    .list(filters)\n    .ensureF(\n      _.nonEmpty,\n      Logger[IO]\n        .error("No matching job found for request")\n        .as(JobResult.NotFound)\n    )\n')),(0,a.yg)("p",null,"The ",(0,a.yg)("strong",{parentName:"p"},"attemptF")," operator is useful when you need to perform effects (like logging) during error handling. In this example, when a payment operation fails, we log the specific error before returning a typed error result. This provides rich context about failures while keeping your error handling clean and maintaining your typed error channel."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'private def processJobPayment(job: Job): StepIO[PaymentConfirmation] =\n  paymentService.process(job.cost).seal.attemptF {\n    case PaymentResult.Success(confirmation) => IO.pure(Right(confirmation))\n    case PaymentResult.Declined => \n      Logger[IO]\n        .error(s"Payment declined for job ${job.id}")\n        .as(Left(JobResult.PaymentFailed("Payment declined")))\n    case PaymentResult.InsufficientFunds => \n      Logger[IO]\n        .error(s"Insufficient funds for job ${job.id}")\n        .as(Left(JobResult.InsufficientFunds))\n    case PaymentResult.ProcessingError(error) => \n      Logger[IO]\n        .error(s"Payment processing error for job ${job.id}: $error")\n        .as(Left(JobResult.PaymentFailed(error)))\n  }\n')),(0,a.yg)("h3",{id:"-use-inspect-for-comprehensive-logging"},"\u2705 Use inspect for Comprehensive Logging"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'// Log different outcomes differently\nuserValidation.inspect {\n  case Right(user) => logger.info(s"User validated: ${user.email}")\n  case Left(error: ValidationError.InvalidEmail) => \n    logger.warn(s"Invalid email format: ${error.email}")\n  case Left(error) => \n    logger.error(s"Validation failed: $error")\n}\n')),(0,a.yg)("h3",{id:"-use-flattap-for-effectful-side-operations"},"\u2705 Use flatTap for Effectful Side Operations"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// Perform side effects without affecting the main computation\nuser.flatTap(u => \n  auditService.recordAccess(u.id, AccessType.Login)\n)\n")),(0,a.yg)("h2",{id:"5-testing-strategies"},"5. Testing Strategies"),(0,a.yg)("p",null,"Proper testing ensures your Sealed Monad code works as expected."),(0,a.yg)("h3",{id:"-test-all-possible-outcomes"},"\u2705 Test All Possible Outcomes"),(0,a.yg)("p",null,"For each ADT case, write tests that ensure the correct outcome is produced:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'import org.scalatest.flatspec.AnyFlatSpec\nimport org.scalatest.matchers.should.Matchers\nimport cats.effect.unsafe.implicits.global\n\nclass UserServiceSpec extends AnyFlatSpec with Matchers {\n  \n  "UserService.registerUser" should "return Success when registration succeeds" in {\n    val service = new UserService(\n      emailValidator = _ => IO.pure(true),\n      emailRepository = _ => IO.pure(false), // email doesn\'t exist\n      passwordValidator = _ => IO.pure(true),\n      userRepository = (_, _) => IO.pure(User("user-123", "test@example.com"))\n    )\n    \n    val result = service.registerUser(RegisterRequest("test@example.com", "password123"))\n      .unsafeRunSync()\n      \n    result shouldBe RegisterResponse.Success("user-123")\n  }\n  \n  it should "return EmailInvalid when email is invalid" in {\n    val service = new UserService(\n      emailValidator = _ => IO.pure(false), // invalid email\n      emailRepository = _ => IO.pure(false),\n      passwordValidator = _ => IO.pure(true),\n      userRepository = (_, _) => IO.pure(User("user-123", "test@example.com"))\n    )\n    \n    val result = service.registerUser(RegisterRequest("invalid", "password123"))\n      .unsafeRunSync()\n      \n    result shouldBe RegisterResponse.EmailInvalid\n  }\n  \n  // Additional tests for other outcomes\n}\n')),(0,a.yg)("h3",{id:"-test-helper-methods-independently"},"\u2705 Test Helper Methods Independently"),(0,a.yg)("p",null,"Test your helper methods separately to ensure they work correctly in isolation:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'"UserService.validateEmail" should "return valid email when format is correct and email doesn\'t exist" in {\n  val service = new UserService(/* ... */)\n  \n  val result = service.validateEmail("valid@example.com")\n    .run.unsafeRunSync()\n    \n  result shouldBe Right("valid@example.com")\n}\n')),(0,a.yg)("h2",{id:"6-common-pitfalls-and-how-to-avoid-them"},"6. Common Pitfalls and How to Avoid Them"),(0,a.yg)("p",null,"Being aware of common mistakes will help you use Sealed Monad more effectively."),(0,a.yg)("h3",{id:"-dont-forget-to-call-run"},"\u274c Don't: Forget to call .run"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// This doesn't actually execute the computation!\ndef processOrder(id: String): IO[OrderResponse] = {\n  for {\n    order <- orderRepository.findById(id).valueOr(OrderResponse.NotFound)\n    // ...more processing\n  } yield OrderResponse.Success(order.id)\n}\n\n// Correct way - don't forget .run\ndef processOrder(id: String): IO[OrderResponse] = {\n  (for {\n    order <- orderRepository.findById(id).valueOr(OrderResponse.NotFound)\n    // ...more processing\n  } yield OrderResponse.Success(order.id)).run\n}\n")),(0,a.yg)("h3",{id:"-dont-mix-monad-transformers-with-sealed-monad"},"\u274c Don't: Mix Monad Transformers with Sealed Monad"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// Don't mix EitherT with Sealed Monad\ndef processUser(id: String): IO[UserResponse] = {\n  val eitherT = EitherT(userRepository.findById(id).map {\n    case Some(user) => Right(user)\n    case None => Left(UserResponse.NotFound)\n  })\n  \n  // This mixing makes code harder to follow\n  val sealed = for {\n    user <- eitherT.value.fromEither\n    // ...more operations with Sealed Monad\n  } yield UserResponse.Success(user)\n  \n  sealed.run\n}\n\n// Better: stick with one approach\ndef processUser(id: String): IO[UserResponse] = {\n  (for {\n    user <- userRepository.findById(id).valueOr(UserResponse.NotFound)\n    // ...more operations with Sealed Monad\n  } yield UserResponse.Success(user)).run\n}\n")),(0,a.yg)("h3",{id:"-dont-use-overly-complex-transformations"},"\u274c Don't: Use overly complex transformations"),(0,a.yg)("p",null,"If you find yourself writing complex transformations, consider breaking them down into smaller, focused methods:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// Too complex\ndef processOrder(id: String): IO[OrderResponse] = {\n  (for {\n    order <- orderRepository.findById(id).valueOr(OrderResponse.NotFound)\n    _ <- paymentService.process(order.payment).attempt {\n      case Right(_) => Right(())\n      case Left(PaymentError.InsufficientFunds) => Left(OrderResponse.InsufficientFunds)\n      case Left(PaymentError.PaymentDeclined) => Left(OrderResponse.PaymentDeclined)\n      case Left(_) => Left(OrderResponse.PaymentFailed)\n    }\n  } yield OrderResponse.Success(order.id)).run\n}\n\n// Better: Extract complex logic\ndef processOrder(id: String): IO[OrderResponse] = {\n  (for {\n    order <- findOrder(id)\n    _ <- processPayment(order.payment)\n  } yield OrderResponse.Success(order.id)).run\n}\n\nprivate def findOrder(id: String): Sealed[IO, Order, OrderResponse] =\n  orderRepository.findById(id).valueOr(OrderResponse.NotFound)\n\nprivate def processPayment(payment: Payment): Sealed[IO, Unit, OrderResponse] =\n  paymentService.process(payment).attempt {\n    case Right(_) => Right(())\n    case Left(PaymentError.InsufficientFunds) => Left(OrderResponse.InsufficientFunds)\n    case Left(PaymentError.PaymentDeclined) => Left(OrderResponse.PaymentDeclined)\n    case Left(_) => Left(OrderResponse.PaymentFailed)\n  }\n")),(0,a.yg)("h2",{id:"7-migration-strategies"},"7. Migration Strategies"),(0,a.yg)("p",null,"If you're migrating an existing codebase to use Sealed Monad, here are some recommended approaches:"),(0,a.yg)("h3",{id:"gradual-adoption"},"Gradual Adoption"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Start with new code"),": Apply Sealed Monad to new features first"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Identify pain points"),": Target existing code with complex error handling or nested pattern matching"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Refactor incrementally"),": Convert one method or service at a time"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Add comprehensive tests"),": Ensure behavior remains the same after refactoring")),(0,a.yg)("h3",{id:"example-refactoring-path"},"Example Refactoring Path"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Define your ADT for the operation result"),(0,a.yg)("li",{parentName:"ol"},"Identify points where control flow branches (pattern matching, if/else)"),(0,a.yg)("li",{parentName:"ol"},"Convert those to Sealed Monad operations (valueOr, ensure, etc.)"),(0,a.yg)("li",{parentName:"ol"},"Wrap the body in a for-comprehension"),(0,a.yg)("li",{parentName:"ol"},"Add a .run call at the end"),(0,a.yg)("li",{parentName:"ol"},"Extract complex validation logic to helper methods")),(0,a.yg)("h2",{id:"8-real-world-example-api-service"},"8. Real-World Example: API Service"),(0,a.yg)("p",null,"Here's a complete example of an API service using Sealed Monad:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"import cats.effect.IO\nimport pl.iterators.sealedmonad.syntax._\nimport io.circe.generic.auto._\n\n// Domain models\ncase class User(id: String, email: String, name: String, active: Boolean)\ncase class RegisterRequest(email: String, password: String, name: String)\n\n// Result ADT\nsealed trait RegisterResponse\nobject RegisterResponse {\n  case class Success(userId: String) extends RegisterResponse\n  case object EmailAlreadyExists extends RegisterResponse\n  case object InvalidEmailFormat extends RegisterResponse\n  case object PasswordTooWeak extends RegisterResponse\n}\n\nclass UserService(\n  emailValidator: EmailValidator,\n  passwordValidator: PasswordValidator,\n  userRepository: UserRepository\n) {\n  import pl.iterators.sealedmonad.syntax._\n\n  def register(request: RegisterRequest): IO[RegisterResponse] = {\n    (for {\n      // Validate email format\n      _ <- emailValidator.isValid(request.email)\n           .ensure(identity, RegisterResponse.InvalidEmailFormat)\n\n      // Check if email already exists\n      emailExists <- userRepository.emailExists(request.email).seal\n      _ <- (!emailExists).pure[IO]\n           .ensure(identity, RegisterResponse.EmailAlreadyExists)\n\n      // Validate password strength\n      _ <- passwordValidator.isStrong(request.password)\n           .ensure(identity, RegisterResponse.PasswordTooWeak)\n\n      // Create user account\n      user <- userRepository.create(\n                User(generateId(), request.email, request.name, true)\n              ).seal\n    } yield RegisterResponse.Success(user.id)).run\n  }\n\n  private def generateId(): String = java.util.UUID.randomUUID().toString\n}\n")),(0,a.yg)("p",null,"This example demonstrates many Sealed Monad best practices:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Clear separation of high-level flow and implementation details"),(0,a.yg)("li",{parentName:"ul"},"Well-designed ADT for response types"),(0,a.yg)("li",{parentName:"ul"},"Validation performed at appropriate steps"),(0,a.yg)("li",{parentName:"ul"},"Proper error handling and conversion")))}u.isMDXComponent=!0},5680:(e,r,n)=>{n.d(r,{xA:()=>c,yg:()=>m});var t=n(6540);function a(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function s(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function i(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?s(Object(n),!0).forEach((function(r){a(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function o(e,r){if(null==e)return{};var n,t,a=function(e,r){if(null==e)return{};var n,t,a={},s=Object.keys(e);for(t=0;t<s.length;t++)n=s[t],r.indexOf(n)>=0||(a[n]=e[n]);return a}(e,r);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(t=0;t<s.length;t++)n=s[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=t.createContext({}),d=function(e){var r=t.useContext(l),n=r;return e&&(n="function"==typeof e?e(r):i(i({},r),e)),n},c=function(e){var r=d(e.components);return t.createElement(l.Provider,{value:r},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},g=t.forwardRef((function(e,r){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=d(n),g=a,m=u["".concat(l,".").concat(g)]||u[g]||p[g]||s;return n?t.createElement(m,i(i({ref:r},c),{},{components:n})):t.createElement(m,i({ref:r},c))}));function m(e,r){var n=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=g;var o={};for(var l in r)hasOwnProperty.call(r,l)&&(o[l]=r[l]);o.originalType=e,o[u]="string"==typeof e?e:a,i[1]=o;for(var d=2;d<s;d++)i[d]=n[d];return t.createElement.apply(null,i)}return t.createElement.apply(null,n)}g.displayName="MDXCreateElement"}}]);