"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[17],{5680:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>c});var a=t(6540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},g="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),g=p(t),m=r,c=g["".concat(s,".").concat(m)]||g[m]||d[m]||i;return t?a.createElement(c,o(o({ref:n},u),{},{components:t})):a.createElement(c,o({ref:n},u))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[g]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8871:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var a=t(8168),r=(t(6540),t(5680));const i={id:"comparison",title:"Comparison with Other Approaches",slug:"/comparison"},o="Comparison with Other Approaches",l={unversionedId:"comparison",id:"comparison",title:"Comparison with Other Approaches",description:"Sealed Monad offers a distinctive approach to error handling in Scala. This page compares it with other common error handling techniques to help you understand where it fits in the ecosystem.",source:"@site/../docs/comparison.md",sourceDirName:".",slug:"/comparison",permalink:"/sealed-monad/comparison",editUrl:"https://github.com/theiterators/sealed-monad/tree/master/docs/../docs/comparison.md",tags:[],version:"current",frontMatter:{id:"comparison",title:"Comparison with Other Approaches",slug:"/comparison"},sidebar:"docs",previous:{title:"Best Practices",permalink:"/sealed-monad/best-practices"},next:{title:"Migration Guide",permalink:"/sealed-monad/migration-guide"}},s=[{value:"The Example: User Authentication",id:"the-example-user-authentication",children:[],level:2},{value:"Approach 1: Pattern Matching with Options",id:"approach-1-pattern-matching-with-options",children:[],level:2},{value:"Approach 2: Using Cats&#39; EitherT",id:"approach-2-using-cats-eithert",children:[],level:2},{value:"Approach 3: Using Sealed Monad",id:"approach-3-using-sealed-monad",children:[],level:2},{value:"Approach 4: Using ZIO",id:"approach-4-using-zio",children:[],level:2},{value:"When to Use Sealed Monad",id:"when-to-use-sealed-monad",children:[],level:2},{value:"When to Consider Alternatives",id:"when-to-consider-alternatives",children:[],level:2},{value:"Summary",id:"summary",children:[],level:2}],p={toc:s},u="wrapper";function g(e){let{components:n,...t}=e;return(0,r.yg)(u,(0,a.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"comparison-with-other-approaches"},"Comparison with Other Approaches"),(0,r.yg)("p",null,"Sealed Monad offers a distinctive approach to error handling in Scala. This page compares it with other common error handling techniques to help you understand where it fits in the ecosystem."),(0,r.yg)("h2",{id:"the-example-user-authentication"},"The Example: User Authentication"),(0,r.yg)("p",null,"To provide a fair comparison, we'll implement the same example with different error handling approaches. Our example involves user authentication with the following requirements:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Find a user by email"),(0,r.yg)("li",{parentName:"ol"},"Check if the user's account is active (not archived)"),(0,r.yg)("li",{parentName:"ol"},"Verify the authentication method"),(0,r.yg)("li",{parentName:"ol"},"Generate a token or handle the appropriate error case")),(0,r.yg)("p",null,"First, let's define our domain models and result type:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import scala.concurrent.Future\nimport cats.Monad\nimport cats.effect.IO\n\n// Domain models\ncase class User(id: Long, email: String, archived: Boolean)\ncase class AuthMethod(userId: Long, provider: String)\n\n// Result ADT\nsealed trait LoginResponse\nobject LoginResponse {\n  final case class LoggedIn(token: String) extends LoginResponse\n  case object InvalidCredentials extends LoginResponse\n  case object Deleted extends LoginResponse\n  case object ProviderAuthFailed extends LoginResponse\n}\n")),(0,r.yg)("h2",{id:"approach-1-pattern-matching-with-options"},"Approach 1: Pattern Matching with Options"),(0,r.yg)("p",null,"This is perhaps the most common approach in Scala applications:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'def login(\n  email: String,\n  findUser: String => Future[Option[User]],\n  findAuthMethod: (Long, String) => Future[Option[AuthMethod]],\n  checkAuthMethod: AuthMethod => Boolean,\n  issueTokenFor: User => String\n): Future[LoginResponse] = {\n  import scala.concurrent.ExecutionContext.Implicits.global\n  \n  findUser(email).flatMap {\n    case None => \n      Future.successful(LoginResponse.InvalidCredentials)\n    case Some(user) if user.archived => \n      Future.successful(LoginResponse.Deleted)\n    case Some(user) => \n      findAuthMethod(user.id, "email").flatMap {\n        case None => \n          Future.successful(LoginResponse.ProviderAuthFailed)\n        case Some(authMethod) if !checkAuthMethod(authMethod) => \n          Future.successful(LoginResponse.InvalidCredentials)\n        case Some(_) => \n          Future.successful(LoginResponse.LoggedIn(issueTokenFor(user)))\n      }\n  }\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Pros:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Straightforward and familiar to most Scala developers"),(0,r.yg)("li",{parentName:"ul"},"No external libraries required"),(0,r.yg)("li",{parentName:"ul"},"Explicit control flow")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Cons:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Nested pattern matching creates deeply indented code"),(0,r.yg)("li",{parentName:"ul"},'Hard to follow the "happy path" through the nested branches'),(0,r.yg)("li",{parentName:"ul"},"Error handling is mixed with the main flow"),(0,r.yg)("li",{parentName:"ul"},"Difficult to modify without introducing bugs"),(0,r.yg)("li",{parentName:"ul"},"The more conditions or steps, the more unwieldy it becomes")),(0,r.yg)("h2",{id:"approach-2-using-cats-eithert"},"Approach 2: Using Cats' EitherT"),(0,r.yg)("p",null,"EitherT is a monad transformer that combines the Either monad with an arbitrary monad, allowing for composing operations that can return either success or error values:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import cats.data.EitherT\nimport cats.implicits._\n\ndef login(\n  email: String,\n  findUser: String => Future[Option[User]],\n  findAuthMethod: (Long, String) => Future[Option[AuthMethod]],\n  checkAuthMethod: AuthMethod => Boolean,\n  issueTokenFor: User => String\n): Future[LoginResponse] = {\n  import scala.concurrent.ExecutionContext.Implicits.global\n  \n  // Start with user lookup\n  (for {\n    user <- EitherT.fromOptionF(\n      findUser(email),\n      LoginResponse.InvalidCredentials: LoginResponse\n    )\n    \n    // Check if user is archived\n    _ <- EitherT.cond(\n      !user.archived,\n      (),\n      LoginResponse.Deleted: LoginResponse\n    )\n    \n    // Get auth method\n    authMethod <- EitherT.fromOptionF(\n      findAuthMethod(user.id, "email"), \n      LoginResponse.ProviderAuthFailed: LoginResponse\n    )\n    \n    // Check auth method validity\n    _ <- EitherT.cond(\n      checkAuthMethod(authMethod),\n      (),\n      LoginResponse.InvalidCredentials: LoginResponse\n    )\n    \n    // Create success response\n    response = LoginResponse.LoggedIn(issueTokenFor(user))\n  } yield response).merge\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Pros:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Linear flow with for-comprehensions"),(0,r.yg)("li",{parentName:"ul"},"Clear separation of happy path and error cases"),(0,r.yg)("li",{parentName:"ul"},"Makes good use of Scala's type system")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Cons:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Requires understanding monad transformers"),(0,r.yg)("li",{parentName:"ul"},"More verbose for simpler cases"),(0,r.yg)("li",{parentName:"ul"},"Error outcomes and success types are treated differently"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},".merge")," at the end is non-intuitive for new developers"),(0,r.yg)("li",{parentName:"ul"},"Type signatures can be complex")),(0,r.yg)("h2",{id:"approach-3-using-sealed-monad"},"Approach 3: Using Sealed Monad"),(0,r.yg)("p",null,"Now let's implement the same logic using Sealed Monad:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import pl.iterators.sealedmonad.syntax._\n\ndef login(\n  email: String,\n  findUser: String => Future[Option[User]],\n  findAuthMethod: (Long, String) => Future[Option[AuthMethod]],\n  checkAuthMethod: AuthMethod => Boolean,\n  issueTokenFor: User => String\n): Future[LoginResponse] = {\n  import scala.concurrent.ExecutionContext.Implicits.global\n  \n  (for {\n    // Get user or return InvalidCredentials\n    user <- findUser(email)\n      .valueOr[LoginResponse](LoginResponse.InvalidCredentials)\n      .ensure(!_.archived, LoginResponse.Deleted)\n    \n    // Get auth method or return ProviderAuthFailed\n    authMethod <- findAuthMethod(user.id, "email")\n      .valueOr[LoginResponse](LoginResponse.ProviderAuthFailed)\n      .ensure(checkAuthMethod, LoginResponse.InvalidCredentials)\n  } yield LoginResponse.LoggedIn(issueTokenFor(user))).run\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Pros:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Concise, linear flow"),(0,r.yg)("li",{parentName:"ul"},"Declarative error handling directly in the main flow"),(0,r.yg)("li",{parentName:"ul"},"Familiar for-comprehension structure"),(0,r.yg)("li",{parentName:"ul"},"Method names clearly express intent (e.g., ",(0,r.yg)("inlineCode",{parentName:"li"},"valueOr"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"ensure"),")"),(0,r.yg)("li",{parentName:"ul"},"Uniform treatment of all outcomes (both success and error cases)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"run")," clearly indicates when the computation is executed")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Cons:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Requires learning a library-specific API"),(0,r.yg)("li",{parentName:"ul"},"Introduced extra abstraction that needs to be understood")),(0,r.yg)("h2",{id:"approach-4-using-zio"},"Approach 4: Using ZIO"),(0,r.yg)("p",null,"ZIO offers powerful error handling with a distinct approach:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\ndef login(\n  email: String,\n  findUser: String => Task[Option[User]],\n  findAuthMethod: (Long, String) => Task[Option[AuthMethod]],\n  checkAuthMethod: AuthMethod => Boolean,\n  issueTokenFor: User => String\n): Task[LoginResponse] = {\n  \n  // Find user\n  ZIO.fromOption(findUser(email).orDie)\n    .mapError(_ => LoginResponse.InvalidCredentials)\n    \n    // Check if user is archived\n    .filterOrElseWith(\n      user => !user.archived,\n      _ => ZIO.succeed(LoginResponse.Deleted)\n    )\n    \n    // Get auth method\n    .flatMap(user => \n      ZIO.fromOption(findAuthMethod(user.id, "email").orDie)\n        .mapError(_ => LoginResponse.ProviderAuthFailed)\n        \n        // Check auth method validity\n        .filterOrElseWith(\n          authMethod => checkAuthMethod(authMethod),\n          _ => ZIO.succeed(LoginResponse.InvalidCredentials)\n        )\n        \n        // Create success response\n        .map(_ => LoginResponse.LoggedIn(issueTokenFor(user)))\n    ).catchAll(ZIO.succeed(_))\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Pros:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Powerful effect system"),(0,r.yg)("li",{parentName:"ul"},"Strong type safety"),(0,r.yg)("li",{parentName:"ul"},"Comprehensive error handling capabilities")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Cons:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Steeper learning curve"),(0,r.yg)("li",{parentName:"ul"},"More verbose for simple cases"),(0,r.yg)("li",{parentName:"ul"},"Requires adopting the whole ZIO ecosystem")),(0,r.yg)("h2",{id:"when-to-use-sealed-monad"},"When to Use Sealed Monad"),(0,r.yg)("p",null,"Sealed Monad is particularly well-suited for:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Business logic with multiple, well-defined outcomes")),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},'When operations can have several "normal" outcomes (not just success/failure)'),(0,r.yg)("li",{parentName:"ul"},"When modeling with ADTs/sealed traits is natural for your domain"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"API implementations with predictable response types")),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"RESTful services with HTTP status codes mapping to business outcomes"),(0,r.yg)("li",{parentName:"ul"},"GraphQL resolvers with structured error responses"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Workflows with sequential validation steps")),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"User registration flows"),(0,r.yg)("li",{parentName:"ul"},"Payment processing pipelines "),(0,r.yg)("li",{parentName:"ul"},"Multi-step form submissions"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Teams looking for readable, self-documenting code")),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"When code needs to be understood by developers with varied experience levels"),(0,r.yg)("li",{parentName:"ul"},"When business logic should be clear to non-technical stakeholders")))),(0,r.yg)("h2",{id:"when-to-consider-alternatives"},"When to Consider Alternatives"),(0,r.yg)("p",null,"You might prefer other approaches when:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"You need more advanced effect handling")),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"For complex concurrency patterns, ZIO may be more suitable"),(0,r.yg)("li",{parentName:"ul"},"For reactive streaming, consider Fs2 or Akka Streams"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Error handling is an incidental concern")),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"For simple, mostly happy-path operations where errors are rare"),(0,r.yg)("li",{parentName:"ul"},"For CRUD operations with minimal business logic"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Team familiarity is a primary concern")),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"If your team is already experienced with another approach")))),(0,r.yg)("h2",{id:"summary"},"Summary"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null}),(0,r.yg)("th",{parentName:"tr",align:null},"Sealed Monad"),(0,r.yg)("th",{parentName:"tr",align:null},"Pattern Matching"),(0,r.yg)("th",{parentName:"tr",align:null},"EitherT"),(0,r.yg)("th",{parentName:"tr",align:null},"ZIO"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("strong",{parentName:"td"},"Verbosity")),(0,r.yg)("td",{parentName:"tr",align:null},"Low"),(0,r.yg)("td",{parentName:"tr",align:null},"Medium"),(0,r.yg)("td",{parentName:"tr",align:null},"Medium"),(0,r.yg)("td",{parentName:"tr",align:null},"High")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("strong",{parentName:"td"},"Readability")),(0,r.yg)("td",{parentName:"tr",align:null},"High"),(0,r.yg)("td",{parentName:"tr",align:null},"Low"),(0,r.yg)("td",{parentName:"tr",align:null},"Medium"),(0,r.yg)("td",{parentName:"tr",align:null},"Medium")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("strong",{parentName:"td"},"Learning Curve")),(0,r.yg)("td",{parentName:"tr",align:null},"Low"),(0,r.yg)("td",{parentName:"tr",align:null},"None"),(0,r.yg)("td",{parentName:"tr",align:null},"Medium"),(0,r.yg)("td",{parentName:"tr",align:null},"High")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("strong",{parentName:"td"},"Type Safety")),(0,r.yg)("td",{parentName:"tr",align:null},"High"),(0,r.yg)("td",{parentName:"tr",align:null},"Medium"),(0,r.yg)("td",{parentName:"tr",align:null},"High"),(0,r.yg)("td",{parentName:"tr",align:null},"Very High")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("strong",{parentName:"td"},"ADT Support")),(0,r.yg)("td",{parentName:"tr",align:null},"Excellent"),(0,r.yg)("td",{parentName:"tr",align:null},"Good"),(0,r.yg)("td",{parentName:"tr",align:null},"Good"),(0,r.yg)("td",{parentName:"tr",align:null},"Good")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("strong",{parentName:"td"},"Pure FP")),(0,r.yg)("td",{parentName:"tr",align:null},"Yes"),(0,r.yg)("td",{parentName:"tr",align:null},"No"),(0,r.yg)("td",{parentName:"tr",align:null},"Yes"),(0,r.yg)("td",{parentName:"tr",align:null},"Yes")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("strong",{parentName:"td"},"Extensibility")),(0,r.yg)("td",{parentName:"tr",align:null},"Good"),(0,r.yg)("td",{parentName:"tr",align:null},"Limited"),(0,r.yg)("td",{parentName:"tr",align:null},"Good"),(0,r.yg)("td",{parentName:"tr",align:null},"Excellent")))),(0,r.yg)("p",null,"Sealed Monad occupies a sweet spot for many business logic scenarios, offering a balance of readability, type safety, and expressiveness without the complexity of full-featured effect systems."))}g.isMDXComponent=!0}}]);