"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[394],{492:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>i,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var a=n(8168),t=(n(6540),n(5680));const l={id:"api-reference",title:"API Reference",slug:"/api-reference"},o="API Reference",s={unversionedId:"api-reference",id:"api-reference",title:"API Reference",description:"This page documents the core operations and syntax provided by Sealed Monad. The library offers a rich set of operators tailored to different use cases and scenarios.",source:"@site/../docs/api-reference.md",sourceDirName:".",slug:"/api-reference",permalink:"/sealed-monad/api-reference",draft:!1,editUrl:"https://github.com/theiterators/sealed-monad/tree/master/docs/../docs/api-reference.md",tags:[],version:"current",frontMatter:{id:"api-reference",title:"API Reference",slug:"/api-reference"},sidebar:"docs",previous:{title:"Practical Use Cases",permalink:"/sealed-monad/usecases"},next:{title:"Best Practices",permalink:"/sealed-monad/best-practices"}},i={},d=[{value:"Core Type",id:"core-type",level:2},{value:"Creating Sealed Instances",id:"creating-sealed-instances",level:2},{value:"From Effects",id:"from-effects",level:3},{value:"From Options",id:"from-options",level:3},{value:"From Either",id:"from-either",level:3},{value:"Transformations",id:"transformations",level:2},{value:"Basic Transformations",id:"basic-transformations",level:3},{value:"Validation Operations",id:"validation-operations",level:3},{value:"Either/Attempt Operations",id:"eitherattempt-operations",level:3},{value:"Side Effect Operations",id:"side-effect-operations",level:3},{value:"Completion Operations",id:"completion-operations",level:3},{value:"Syntax Extensions",id:"syntax-extensions",level:2},{value:"Usage Best Practices",id:"usage-best-practices",level:2}],p={toc:d},c="wrapper";function u(e){let{components:r,...n}=e;return(0,t.yg)(c,(0,a.A)({},p,n,{components:r,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"api-reference"},"API Reference"),(0,t.yg)("p",null,"This page documents the core operations and syntax provided by Sealed Monad. The library offers a rich set of operators tailored to different use cases and scenarios."),(0,t.yg)("h2",{id:"core-type"},"Core Type"),(0,t.yg)("p",null,"The fundamental type in Sealed Monad is ",(0,t.yg)("inlineCode",{parentName:"p"},"Sealed[F[_], +A, +ADT]")," with three type parameters:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"F[_]"),": The effect type (e.g., ",(0,t.yg)("inlineCode",{parentName:"li"},"Future"),", ",(0,t.yg)("inlineCode",{parentName:"li"},"IO"),", ",(0,t.yg)("inlineCode",{parentName:"li"},"Id"),")"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"A"),": The intermediate value type "),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"ADT"),': The final value or "result" type (typically a sealed trait hierarchy)')),(0,t.yg)("p",null,"Sealed Monad is designed around the principle that all possible outcomes of an operation should be represented as part of a single ADT (Algebraic Data Type). In this design, successful outcomes are typically represented as case classes that extend the result ADT, while error conditions are represented as case objects of the same ADT."),(0,t.yg)("p",null,"For example:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait UserResponse\ncase class Success(user: User) extends UserResponse\ncase object NotFound extends UserResponse\ncase object Unauthorized extends UserResponse\n")),(0,t.yg)("p",null,"This design allows the ",(0,t.yg)("inlineCode",{parentName:"p"},"run")," method to return a single, unified type that can represent all possible outcomes of the operation."),(0,t.yg)("h2",{id:"creating-sealed-instances"},"Creating Sealed Instances"),(0,t.yg)("h3",{id:"from-effects"},"From Effects"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'// From F[A]\ndef seal[ADT]: Sealed[F, A, ADT]\n// Example:\nval sealedValue: Sealed[IO, Int, String] = IO.pure(42).seal[String]\n\n// From pure values \ndef liftSealed[F[_], ADT]: Sealed[F, A, ADT]\n// Example:\nval sealedValue: Sealed[IO, Int, String] = 42.liftSealed[IO, String]\n\n// From ADT values\ndef seal[F[_]]: Sealed[F, Nothing, A]\n// Example:\nval sealedError: Sealed[IO, Nothing, String] = "error".seal[IO]\n')),(0,t.yg)("h3",{id:"from-options"},"From Options"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'// valueOr - extract value from Option or return ADT\ndef valueOr[ADT](orElse: => ADT): Sealed[F, A, ADT]\n// Example:\nval maybeUser: IO[Option[User]] = userRepository.findById(userId)\nval sealedUser: Sealed[IO, User, MyError] = maybeUser.valueOr(MyError.UserNotFound)\n\n// valueOrF - extract value from Option or return effectful ADT\ndef valueOrF[ADT](orElse: => F[ADT]): Sealed[F, A, ADT]\n// Example:\nval sealedUser: Sealed[IO, User, MyError] = \n  maybeUser.valueOrF(Logger[IO].error("User not found") *> IO.pure(MyError.UserNotFound))\n')),(0,t.yg)("h3",{id:"from-either"},"From Either"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"// Convert F[Either[A, B]] to Sealed[F, B, A]\ndef fromEither: Sealed[F, B, A]\n// Example:\nval result: IO[Either[String, Int]] = validateInput(data)\nval sealedResult: Sealed[IO, Int, String] = result.fromEither\n\n// handleError - convert F[Either[A, B]] to Sealed[F, B, ADT]\ndef handleError[ADT](f: A => ADT): Sealed[F, B, ADT]\n// Example:\nval sealedResult: Sealed[IO, Int, MyError] = \n  result.handleError(msg => MyError.ValidationFailed(msg))\n")),(0,t.yg)("h2",{id:"transformations"},"Transformations"),(0,t.yg)("p",null,"Once you have a ",(0,t.yg)("inlineCode",{parentName:"p"},"Sealed")," instance, you can use these operations:"),(0,t.yg)("h3",{id:"basic-transformations"},"Basic Transformations"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"// Transform intermediate value\ndef map[B](f: A => B): Sealed[F, B, ADT]\n// Example:\nval user: Sealed[IO, User, MyError] = getUserById(id)\nval username: Sealed[IO, String, MyError] = user.map(_.name)\n\n// Monadic binding (flatMap)\ndef flatMap[B, ADT1 >: ADT](f: A => Sealed[F, B, ADT1]): Sealed[F, B, ADT1]\n// Example:\nval user: Sealed[IO, User, MyError] = getUserById(id)\nval orders: Sealed[IO, List[Order], MyError] = user.flatMap(u => getOrdersByUser(u.id))\n\n// Transform with effects\ndef semiflatMap[B](f: A => F[B]): Sealed[F, B, ADT]\n// Example:\nval enrichedUser: Sealed[IO, EnrichedUser, MyError] = \n  user.semiflatMap(u => fetchUserPreferences(u.id).map(prefs => EnrichedUser(u, prefs)))\n")),(0,t.yg)("h3",{id:"validation-operations"},"Validation Operations"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'// Ensure condition is met\ndef ensure[ADT1 >: ADT](pred: A => Boolean, orElse: => ADT1): Sealed[F, A, ADT1]\n// Example:\nval activeUser: Sealed[IO, User, MyError] = \n  user.ensure(u => !u.archived, MyError.UserInactive)\n\n// Ensure with effectful orElse\ndef ensureF[ADT1 >: ADT](pred: A => Boolean, orElse: => F[ADT1]): Sealed[F, A, ADT1]\n// Example:\nval activeUser: Sealed[IO, User, MyError] = \n  user.ensureF(\n    u => !u.archived, \n    logger.warn("Archived user access attempt") *> IO.pure(MyError.UserInactive)\n  )\n\n// Ensure condition is not met\ndef ensureNot[ADT1 >: ADT](pred: A => Boolean, orElse: => ADT1): Sealed[F, A, ADT1]\n// Example:\nval newUser: Sealed[IO, User, MyError] = \n  user.ensureNot(_.hasOrders, MyError.UserHasOrders)\n\n// With access to A in orElse\ndef ensureOr[ADT1 >: ADT](pred: A => Boolean, orElse: A => ADT1): Sealed[F, A, ADT1]\n// Example:\nval validUser: Sealed[IO, User, MyError] = \n  user.ensureOr(\n    _.emailConfirmed, \n    u => MyError.EmailNotConfirmed(u.email)\n  )\n')),(0,t.yg)("h3",{id:"eitherattempt-operations"},"Either/Attempt Operations"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"// Process value through Either-returning function\ndef attempt[B, ADT1 >: ADT](f: A => Either[ADT1, B]): Sealed[F, B, ADT1]\n// Example:\nval processedOrder: Sealed[IO, ProcessedOrder, OrderError] =\n  order.attempt { order =>\n    if (order.items.isEmpty) Left(OrderError.EmptyOrder)\n    else if (order.totalAmount <= 0) Left(OrderError.InvalidAmount)\n    else Right(ProcessedOrder(order.id, order.totalAmount))\n  }\n\n// Effectful attempt\ndef attemptF[B, ADT1 >: ADT](f: A => F[Either[ADT1, B]]): Sealed[F, B, ADT1]\n// Example:\nval validatedOrder: Sealed[IO, ValidatedOrder, OrderError] =\n  order.attemptF { order => \n    validateItems(order.items).map {\n      case true => Right(ValidatedOrder(order))\n      case false => Left(OrderError.InvalidItems)\n    }\n  }\n")),(0,t.yg)("h3",{id:"side-effect-operations"},"Side Effect Operations"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'// Apply side effects on intermediate value\ndef tap[B](f: A => B): Sealed[F, A, ADT]\n// Example:\nval loggedUser: Sealed[IO, User, UserError] = \n  user.tap(u => println(s"User found: ${u.email}"))\n\n// Apply effectful side effects\ndef flatTap[B](f: A => F[B]): Sealed[F, A, ADT]\n// Example:\nval loggedUser: Sealed[IO, User, UserError] = \n  user.flatTap(u => logger.info(s"User ${u.id} accessed the system"))\n\n// Inspect current state for debugging\ndef inspect(pf: PartialFunction[Either[ADT, A], Any]): Sealed[F, A, ADT]\n// Example:\nval debuggedLogin: Sealed[IO, User, LoginError] =\n  user.inspect {\n    case Right(u) => println(s"Success: Found user ${u.email}")\n    case Left(LoginError.InvalidCredentials) => println("Error: Invalid credentials")\n    case Left(err) => println(s"Error: $err")\n  }\n')),(0,t.yg)("h3",{id:"completion-operations"},"Completion Operations"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"// Complete with final ADT value based on intermediate value\ndef complete[ADT1 >: ADT](f: A => ADT1): Sealed[F, Nothing, ADT1]\n// Example:\nval loginResponse: Sealed[IO, Nothing, LoginResponse] = \n  user.complete(u => LoginResponse.LoggedIn(generateToken(u)))\n\n// Complete with effectful ADT value\ndef completeWith[ADT1 >: ADT](f: A => F[ADT1]): Sealed[F, Nothing, ADT1]\n// Example:\nval orderResponse: Sealed[IO, Nothing, OrderResponse] =\n  order.completeWith(o => createOrderInDatabase(o).map(id => OrderResponse.Created(id)))\n\n// Evaluate to final result\ndef run[ADT1 >: ADT](implicit ev: A <:< ADT1, F: Monad[F]): F[ADT1]\n// Example:\nval result: IO[LoginResponse] = loginFlow.run\n")),(0,t.yg)("h2",{id:"syntax-extensions"},"Syntax Extensions"),(0,t.yg)("p",null,"Sealed Monad provides extension methods for various types through its syntax import:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import pl.iterators.sealedmonad.syntax._\n")),(0,t.yg)("p",null,"This enables all the syntax shown in the examples above."),(0,t.yg)("h2",{id:"usage-best-practices"},"Usage Best Practices"),(0,t.yg)("ol",null,(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Start with effects")," - Begin your computation with extension methods like ",(0,t.yg)("inlineCode",{parentName:"li"},".valueOr"),", ",(0,t.yg)("inlineCode",{parentName:"li"},".ensure"),", or ",(0,t.yg)("inlineCode",{parentName:"li"},".seal")),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Chain with for-comprehensions")," - Use for-comprehensions to chain operations"),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"End with run")," - Complete your computation with ",(0,t.yg)("inlineCode",{parentName:"li"},".run")," to get the final ",(0,t.yg)("inlineCode",{parentName:"li"},"F[ADT]")),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Structure complex logic in steps")," - Break down complex flows into well-named helper methods"),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Use descriptive ADTs")," - Design your ADT to clearly communicate all possible outcomes")),(0,t.yg)("p",null,"For complete API documentation, refer to the ",(0,t.yg)("a",{parentName:"p",href:"https://javadoc.io/doc/pl.iterators/sealed-monad_2.13/latest/index.html"},"Scaladoc"),"."))}u.isMDXComponent=!0},5680:(e,r,n)=>{n.d(r,{xA:()=>p,yg:()=>f});var a=n(6540);function t(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function l(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?l(Object(n),!0).forEach((function(r){t(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function s(e,r){if(null==e)return{};var n,a,t=function(e,r){if(null==e)return{};var n,a,t={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],r.indexOf(n)>=0||(t[n]=e[n]);return t}(e,r);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(t[n]=e[n])}return t}var i=a.createContext({}),d=function(e){var r=a.useContext(i),n=r;return e&&(n="function"==typeof e?e(r):o(o({},r),e)),n},p=function(e){var r=d(e.components);return a.createElement(i.Provider,{value:r},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var r=e.children;return a.createElement(a.Fragment,{},r)}},m=a.forwardRef((function(e,r){var n=e.components,t=e.mdxType,l=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),m=t,f=c["".concat(i,".").concat(m)]||c[m]||u[m]||l;return n?a.createElement(f,o(o({ref:r},p),{},{components:n})):a.createElement(f,o({ref:r},p))}));function f(e,r){var n=arguments,t=r&&r.mdxType;if("string"==typeof e||t){var l=n.length,o=new Array(l);o[0]=m;var s={};for(var i in r)hasOwnProperty.call(r,i)&&(s[i]=r[i]);s.originalType=e,s[c]="string"==typeof e?e:t,o[1]=s;for(var d=2;d<l;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);