"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[433],{5680:(e,n,s)=>{s.d(n,{xA:()=>p,yg:()=>g});var r=s(6540);function t(e,n,s){return n in e?Object.defineProperty(e,n,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[n]=s,e}function a(e,n){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),s.push.apply(s,r)}return s}function i(e){for(var n=1;n<arguments.length;n++){var s=null!=arguments[n]?arguments[n]:{};n%2?a(Object(s),!0).forEach((function(n){t(e,n,s[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):a(Object(s)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(s,n))}))}return e}function o(e,n){if(null==e)return{};var s,r,t=function(e,n){if(null==e)return{};var s,r,t={},a=Object.keys(e);for(r=0;r<a.length;r++)s=a[r],n.indexOf(s)>=0||(t[s]=e[s]);return t}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)s=a[r],n.indexOf(s)>=0||Object.prototype.propertyIsEnumerable.call(e,s)&&(t[s]=e[s])}return t}var l=r.createContext({}),d=function(e){var n=r.useContext(l),s=n;return e&&(s="function"==typeof e?e(n):i(i({},n),e)),s},p=function(e){var n=d(e.components);return r.createElement(l.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var s=e.components,t=e.mdxType,a=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=d(s),m=t,g=c["".concat(l,".").concat(m)]||c[m]||u[m]||a;return s?r.createElement(g,i(i({ref:n},p),{},{components:s})):r.createElement(g,i({ref:n},p))}));function g(e,n){var s=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var a=s.length,i=new Array(a);i[0]=m;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[c]="string"==typeof e?e:t,i[1]=o;for(var d=2;d<a;d++)i[d]=s[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,s)}m.displayName="MDXCreateElement"},5718:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var r=s(8168),t=(s(6540),s(5680));const a={id:"usecases",title:"Practical Use Cases",slug:"/usecases"},i="Practical Use Cases",o={unversionedId:"usecases",id:"usecases",title:"Practical Use Cases",description:"Sealed Monad shines in real-world business logic scenarios. This section demonstrates practical examples showing how Sealed Monad improves readability and maintainability in different contexts.",source:"@site/../docs/usecases.md",sourceDirName:".",slug:"/usecases",permalink:"/sealed-monad/usecases",draft:!1,editUrl:"https://github.com/theiterators/sealed-monad/tree/master/docs/../docs/usecases.md",tags:[],version:"current",frontMatter:{id:"usecases",title:"Practical Use Cases",slug:"/usecases"},sidebar:"docs",previous:{title:"Installation Guide",permalink:"/sealed-monad/installation"},next:{title:"API Reference",permalink:"/sealed-monad/api-reference"}},l={},d=[{value:"Use Case 1: Form Validation &amp; Processing",id:"use-case-1-form-validation--processing",level:2},{value:"The Response ADT",id:"the-response-adt",level:3},{value:"Implementation with Sealed Monad",id:"implementation-with-sealed-monad",level:3},{value:"Use Case 2: Structuring Complex Services",id:"use-case-2-structuring-complex-services",level:2},{value:"The Response ADT",id:"the-response-adt-1",level:3},{value:"Tiered Service Implementation",id:"tiered-service-implementation",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2}],p={toc:d},c="wrapper";function u(e){let{components:n,...s}=e;return(0,t.yg)(c,(0,r.A)({},p,s,{components:n,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"practical-use-cases"},"Practical Use Cases"),(0,t.yg)("p",null,"Sealed Monad shines in real-world business logic scenarios. This section demonstrates practical examples showing how Sealed Monad improves readability and maintainability in different contexts."),(0,t.yg)("blockquote",null,(0,t.yg)("p",{parentName:"blockquote"},(0,t.yg)("strong",{parentName:"p"},"Note:")," You can find complete, runnable versions of these examples in the ",(0,t.yg)("a",{parentName:"p",href:"https://github.com/theiterators/sealed-monad/tree/master/examples/src"},"examples directory"),".")),(0,t.yg)("h2",{id:"use-case-1-form-validation--processing"},"Use Case 1: Form Validation & Processing"),(0,t.yg)("p",null,"When processing form input, multiple validations often need to be performed before proceeding. Sealed Monad provides a clean way to express this workflow."),(0,t.yg)("h3",{id:"the-response-adt"},"The Response ADT"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait RegistrationResponse\nobject RegistrationResponse {\n  case class Success(userId: String) extends RegistrationResponse\n  case object EmailInvalid extends RegistrationResponse\n  case object EmailTaken extends RegistrationResponse\n  case object PasswordTooWeak extends RegistrationResponse\n  case object AddressInvalid extends RegistrationResponse\n}\n")),(0,t.yg)("h3",{id:"implementation-with-sealed-monad"},"Implementation with Sealed Monad"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import pl.iterators.sealedmonad.syntax._\n\ndef registerUser(\n  email: String,\n  password: String,\n  address: Address,\n  validateEmail: String => Future[Boolean],\n  checkEmailExists: String => Future[Boolean],\n  validatePassword: String => Future[Boolean],\n  validateAddress: Address => Future[Boolean],\n  createUser: (String, String, Address) => Future[User]\n): Future[RegistrationResponse] = {\n  (for {\n    // Validate email format\n    _ <- validateEmail(email)\n          .ensure(isValid => isValid, RegistrationResponse.EmailInvalid)\n    \n    // Check if email is already taken\n    emailExistsCheck <- checkEmailExists(email).seal\n    _ <- (!emailExistsCheck).pure[Future]\n          .ensure(notTaken => notTaken, RegistrationResponse.EmailTaken)\n    \n    // Validate password strength\n    _ <- validatePassword(password)\n          .ensure(isStrong => isStrong, RegistrationResponse.PasswordTooWeak)\n    \n    // Validate address\n    _ <- validateAddress(address)\n          .ensure(isValid => isValid, RegistrationResponse.AddressInvalid)\n    \n    // Create user\n    user <- createUser(email, password, address).seal\n  } yield RegistrationResponse.Success(user.id)).run\n}\n")),(0,t.yg)("p",null,"What makes this approach powerful:"),(0,t.yg)("ol",null,(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Clear sequence")," - Each validation step is explicit and in logical order"),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Early return")," - Any validation failure short-circuits the entire computation"),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Flat structure")," - No nested indentation, improving readability"),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Self-documenting")," - The code clearly represents the business process")),(0,t.yg)("h2",{id:"use-case-2-structuring-complex-services"},"Use Case 2: Structuring Complex Services"),(0,t.yg)("p",null,"For complex business logic, Sealed Monad enables a tiered approach with clear abstraction layers."),(0,t.yg)("h3",{id:"the-response-adt-1"},"The Response ADT"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait OrderProcessingResponse\nobject OrderProcessingResponse {\n  case class Success(orderId: String) extends OrderProcessingResponse\n  case object UserNotFound extends OrderProcessingResponse\n  case object ProductNotFound extends OrderProcessingResponse\n  case object InsufficientStock extends OrderProcessingResponse\n  case object PaymentFailed extends OrderProcessingResponse\n  case object ShippingUnavailable extends OrderProcessingResponse\n}\n")),(0,t.yg)("h3",{id:"tiered-service-implementation"},"Tiered Service Implementation"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'import pl.iterators.sealedmonad.syntax._\nimport pl.iterators.sealedmonad.Sealed\n\nclass OrderService[F[_]: Monad](\n  userRepository: UserRepository[F],\n  productRepository: ProductRepository[F],\n  paymentService: PaymentService[F],\n  shippingService: ShippingService[F],\n  orderRepository: OrderRepository[F]\n) {\n  // High-level business flow\n  def processOrder(userId: String, items: List[OrderItem]): F[OrderProcessingResponse] = {\n    (for {\n      user      <- findUser(userId)\n      products  <- validateProducts(items)\n      payment   <- processPayment(user, products)\n      shipping  <- arrangeShipping(user, products)\n      order     <- createOrder(user, items, payment, shipping)\n    } yield OrderProcessingResponse.Success(order.id)).run\n  }\n\n  // Mid-level methods with focused responsibilities\n  private def findUser(userId: String): Sealed[F, User, OrderProcessingResponse] = \n    userRepository.findById(userId)\n      .valueOr(OrderProcessingResponse.UserNotFound)\n\n  private def validateProducts(items: List[OrderItem]): Sealed[F, List[Product], OrderProcessingResponse] = {\n    // Implementation to look up and validate each product\n    Monad[F].pure(List.empty[Product]).seal  // Simplified\n  }\n\n  private def processPayment(\n    user: User, \n    products: List[Product]\n  ): Sealed[F, String, OrderProcessingResponse] = {\n    // Implementation to process payment\n    Monad[F].pure("payment-123").seal  // Simplified\n  }\n\n  private def arrangeShipping(\n    user: User, \n    products: List[Product]\n  ): Sealed[F, String, OrderProcessingResponse] = {\n    // Implementation to arrange shipping\n    Monad[F].pure("shipping-456").seal  // Simplified\n  }\n\n  private def createOrder(\n    user: User, \n    items: List[OrderItem],\n    paymentId: String,\n    shippingId: String\n  ): Sealed[F, Order, OrderProcessingResponse] = {\n    // Implementation to create and store the order\n    Monad[F].pure(Order("order-789", user.id, items)).seal  // Simplified\n  }\n}\n')),(0,t.yg)("p",null,"Benefits of this structure:"),(0,t.yg)("ol",null,(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"High-level readability")," - The main flow consists of descriptive steps"),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Progressive disclosure")," - Implementation details are encapsulated in well-named methods"),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Separation of concerns")," - Each step handles a specific part of the business logic"),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Testability")," - Each step can be tested independently")),(0,t.yg)("h2",{id:"key-takeaways"},"Key Takeaways"),(0,t.yg)("p",null,"These examples demonstrate how Sealed Monad can improve your code by:"),(0,t.yg)("ol",null,(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Flattening nested logic")," - No more deeply indented conditional blocks"),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Providing clear failure paths")," - Each validation step maps to a specific response"),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Enabling abstraction layers")," - From high-level flows to implementation details"),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"Standardizing error handling")," - Consistent approach across different operations")),(0,t.yg)("p",null,"For more examples and detailed explanations, see the ",(0,t.yg)("a",{parentName:"p",href:"best-practices"},"Best Practices")," sections."))}u.isMDXComponent=!0}}]);