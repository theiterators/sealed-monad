"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[167],{729:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var r=n(8168),a=(n(6540),n(5680));const i={id:"migration-guide",title:"Migration Guide",slug:"/migration-guide"},o="Migration Guide",s={unversionedId:"migration-guide",id:"migration-guide",title:"Migration Guide",description:"This guide provides step-by-step instructions for migrating existing code to use Sealed Monad. Whether you're currently using nested pattern matching, EitherT, or another approach, this guide will help you transition smoothly.",source:"@site/../docs/migration-guide.md",sourceDirName:".",slug:"/migration-guide",permalink:"/sealed-monad/migration-guide",draft:!1,editUrl:"https://github.com/theiterators/sealed-monad/tree/master/docs/../docs/migration-guide.md",tags:[],version:"current",frontMatter:{id:"migration-guide",title:"Migration Guide",slug:"/migration-guide"},sidebar:"docs",previous:{title:"Comparison with Other Approaches",permalink:"/sealed-monad/comparison"},next:{title:"Frequently Asked Questions",permalink:"/sealed-monad/faq"}},l={},d=[{value:"Migrating from Pattern Matching",id:"migrating-from-pattern-matching",level:2},{value:"Before:",id:"before",level:3},{value:"Migration Steps:",id:"migration-steps",level:3},{value:"After:",id:"after",level:3},{value:"Migrating from Try/Either/Exception Handling",id:"migrating-from-tryeitherexception-handling",level:2},{value:"Before:",id:"before-1",level:3},{value:"Migration Steps:",id:"migration-steps-1",level:3},{value:"After:",id:"after-1",level:3},{value:"Gradual Migration Strategy",id:"gradual-migration-strategy",level:2},{value:"Mixing Sealed Monad with Other Approaches",id:"mixing-sealed-monad-with-other-approaches",level:2},{value:"Integrating with EitherT",id:"integrating-with-eithert",level:3},{value:"Integrating with Option-returning functions",id:"integrating-with-option-returning-functions",level:3},{value:"Example: Migrating a Service Class",id:"example-migrating-a-service-class",level:2},{value:"Before:",id:"before-2",level:3},{value:"After:",id:"after-2",level:3},{value:"Final Checklist",id:"final-checklist",level:2},{value:"Migrating from EitherT",id:"migrating-from-eithert",level:2},{value:"Before:",id:"before-3",level:3},{value:"Migration Steps:",id:"migration-steps-2",level:3},{value:"After:",id:"after-3",level:3}],p={toc:d},u="wrapper";function c(e){let{components:t,...n}=e;return(0,a.yg)(u,(0,r.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"migration-guide"},"Migration Guide"),(0,a.yg)("p",null,"This guide provides step-by-step instructions for migrating existing code to use Sealed Monad. Whether you're currently using nested pattern matching, EitherT, or another approach, this guide will help you transition smoothly."),(0,a.yg)("h2",{id:"migrating-from-pattern-matching"},"Migrating from Pattern Matching"),(0,a.yg)("p",null,"If you're currently using nested pattern matching with Options or Either, here's how to migrate to Sealed Monad."),(0,a.yg)("h3",{id:"before"},"Before:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"def confirmEmail(\n  token: String,\n  findAuthMethod: String => Future[Option[AuthMethod]],\n  findUser: Long => Future[Option[User]],\n  upsertAuthMethod: AuthMethod => Future[Int],\n  issueTokenFor: User => String,\n  confirmMethod: AuthMethod => AuthMethod\n): Future[ConfirmResponse] = {\n  import scala.concurrent.ExecutionContext.Implicits.global\n  \n  findAuthMethod(token).flatMap {\n    case None =>\n      Future.successful(ConfirmResponse.MethodNotFound)\n    case Some(method) =>\n      findUser(method.userId).flatMap {\n        case None =>\n          Future.successful(ConfirmResponse.UserNotFound)\n        case Some(user) =>\n          upsertAuthMethod(confirmMethod(method)).map { _ =>\n            ConfirmResponse.Confirmed(issueTokenFor(user))\n          }\n      }\n  }\n}\n")),(0,a.yg)("h3",{id:"migration-steps"},"Migration Steps:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Identify the result ADT"),": Make sure you have a sealed trait hierarchy for the responses.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait ConfirmResponse\nobject ConfirmResponse {\n  case object MethodNotFound extends ConfirmResponse\n  case object UserNotFound extends ConfirmResponse\n  final case class Confirmed(token: String) extends ConfirmResponse\n}\n")),(0,a.yg)("ol",{start:2},(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Import the Sealed Monad syntax"),": Add the import at the top of your file.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"import pl.iterators.sealedmonad.syntax._\n")),(0,a.yg)("ol",{start:3},(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Identify the pattern matching branches"),": Look for places where you're pattern matching on Option/Either results.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Rewrite using Sealed Monad operators"),":"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Use ",(0,a.yg)("inlineCode",{parentName:"li"},"valueOr")," for Option extraction"),(0,a.yg)("li",{parentName:"ul"},"Use ",(0,a.yg)("inlineCode",{parentName:"li"},"ensure")," for conditional checks"),(0,a.yg)("li",{parentName:"ul"},"Use ",(0,a.yg)("inlineCode",{parentName:"li"},"attempt")," for Either conversion"))),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Structure as a for-comprehension"),": Put the steps in a for-comprehension.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Add the .run call"),": Complete the computation with ",(0,a.yg)("inlineCode",{parentName:"p"},".run"),"."))),(0,a.yg)("h3",{id:"after"},"After:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"def confirmEmail(\n  token: String,\n  findAuthMethod: String => Future[Option[AuthMethod]],\n  findUser: Long => Future[Option[User]],\n  upsertAuthMethod: AuthMethod => Future[Int],\n  issueTokenFor: User => String,\n  confirmMethod: AuthMethod => AuthMethod\n): Future[ConfirmResponse] = {\n  import scala.concurrent.ExecutionContext.Implicits.global\n  \n  (for {\n    // Find auth method or return MethodNotFound\n    method <- findAuthMethod(token)\n              .valueOr[ConfirmResponse](ConfirmResponse.MethodNotFound)\n\n    // Find user or return UserNotFound\n    user <- findUser(method.userId)\n            .valueOr[ConfirmResponse](ConfirmResponse.UserNotFound)\n\n    // Update auth method\n    _ <- upsertAuthMethod(confirmMethod(method)).seal\n  } yield ConfirmResponse.Confirmed(issueTokenFor(user))).run\n}\n")),(0,a.yg)("h2",{id:"migrating-from-tryeitherexception-handling"},"Migrating from Try/Either/Exception Handling"),(0,a.yg)("p",null,"If you're using traditional Try/Either or exception handling, follow these steps:"),(0,a.yg)("h3",{id:"before-1"},"Before:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"def processOrder(\n  orderId: String,\n  orderRepository: OrderRepository,\n  paymentService: PaymentService,\n  shippingService: ShippingService\n): Future[OrderProcessingResult] = {\n  import scala.concurrent.ExecutionContext.Implicits.global\n  import scala.util.{Success, Failure}\n  \n  orderRepository.findById(orderId).flatMap {\n    case None => \n      Future.successful(OrderProcessingResult.NotFound)\n    case Some(order) =>\n      if (order.isExpired) {\n        Future.successful(OrderProcessingResult.Expired)\n      } else {\n        paymentService.processPayment(order.id, order.amount).flatMap {\n          case Success(paymentId) =>\n            shippingService.arrangeShipping(order).transform {\n              case Success(trackingId) => \n                Success(OrderProcessingResult.Completed(trackingId))\n              case Failure(_) => \n                Success(OrderProcessingResult.ShippingFailed)\n            }\n          case Failure(e: InsufficientFundsException) =>\n            Future.successful(OrderProcessingResult.InsufficientFunds)\n          case Failure(_) =>\n            Future.successful(OrderProcessingResult.PaymentFailed)\n        }\n      }\n  }\n}\n")),(0,a.yg)("h3",{id:"migration-steps-1"},"Migration Steps:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Define your ADT"),": Ensure your result type is a sealed trait with all possible outcomes.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Restructure as a linear flow"),": Identify the steps and convert to a for-comprehension.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Use appropriate operators"),": Replace conditionals with ",(0,a.yg)("inlineCode",{parentName:"p"},"ensure"),", exceptions with ",(0,a.yg)("inlineCode",{parentName:"p"},"attempt"),"."))),(0,a.yg)("h3",{id:"after-1"},"After:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"def processOrder(\n  orderId: String,\n  orderRepository: OrderRepository,\n  paymentService: PaymentService,\n  shippingService: ShippingService\n): Future[OrderProcessingResult] = {\n  import scala.concurrent.ExecutionContext.Implicits.global\n  import pl.iterators.sealedmonad.syntax._\n  \n  (for {\n    // Find order or return NotFound\n    order <- orderRepository.findById(orderId)\n              .valueOr[OrderProcessingResult](OrderProcessingResult.NotFound)\n              \n    // Check if order is expired\n    _ <- order.pure[Future]\n           .ensure(!_.isExpired, OrderProcessingResult.Expired)\n           \n    // Process payment\n    paymentId <- paymentService.processPayment(order.id, order.amount)\n                  .attempt {\n                    case Success(id) => Right(id)\n                    case Failure(e: InsufficientFundsException) => \n                      Left(OrderProcessingResult.InsufficientFunds)\n                    case Failure(_) => \n                      Left(OrderProcessingResult.PaymentFailed)\n                  }\n                  \n    // Arrange shipping\n    trackingId <- shippingService.arrangeShipping(order)\n                   .attempt {\n                     case Success(id) => Right(id)\n                     case Failure(_) => Left(OrderProcessingResult.ShippingFailed)\n                   }\n  } yield OrderProcessingResult.Completed(trackingId)).run\n}\n")),(0,a.yg)("h2",{id:"gradual-migration-strategy"},"Gradual Migration Strategy"),(0,a.yg)("p",null,"When migrating a large codebase, consider this gradual approach:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Start with leaf methods"),": Begin with methods that don't depend on other methods returning ADTs.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Create ADT wrappers"),": For methods you're not ready to migrate, create wrappers that return the appropriate ADT."))),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// Original method\ndef findUser(id: String): Future[Option[User]] = ???\n\n// Wrapper for use with Sealed Monad\ndef findUserOrError(id: String): Future[UserResponse] =\n  findUser(id).map(_.fold[UserResponse](UserResponse.NotFound)(UserResponse.Found))\n")),(0,a.yg)("ol",{start:3},(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Migrate core business logic first"),": Focus on complex business logic with multiple error cases first, as these will benefit most from Sealed Monad.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Update tests"),": Make sure to update tests to verify both success and failure paths.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Refactor in small, focused PRs"),": Don't try to migrate everything at once. Focus on small, manageable pull requests."))),(0,a.yg)("h2",{id:"mixing-sealed-monad-with-other-approaches"},"Mixing Sealed Monad with Other Approaches"),(0,a.yg)("p",null,"During migration, you might need to mix Sealed Monad with existing approaches:"),(0,a.yg)("h3",{id:"integrating-with-eithert"},"Integrating with EitherT"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"import cats.data.EitherT\nimport cats.implicits._\nimport pl.iterators.sealedmonad.Sealed\nimport pl.iterators.sealedmonad.syntax._\n\n// Convert from EitherT to Sealed\ndef fromEitherT[F[_], A, B](eitherT: EitherT[F, B, A])(implicit M: Monad[F]): Sealed[F, A, B] =\n  Sealed(eitherT.value).rethrow\n\n// Convert from Sealed to EitherT\ndef toEitherT[F[_]: Monad, A, B](sealed: Sealed[F, A, B]): EitherT[F, B, A] =\n  EitherT(sealed.either.run)\n")),(0,a.yg)("h3",{id:"integrating-with-option-returning-functions"},"Integrating with Option-returning functions"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"// When calling external code that returns Option\ndef callLegacyCode(id: String): Sealed[F, User, UserError] =\n  legacyService.findUserById(id).valueOr(UserError.NotFound)\n")),(0,a.yg)("h2",{id:"example-migrating-a-service-class"},"Example: Migrating a Service Class"),(0,a.yg)("p",null,"Here's a complete example of migrating a service class:"),(0,a.yg)("h3",{id:"before-2"},"Before:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'class OrderService(\n  repository: OrderRepository,\n  paymentService: PaymentService,\n  notificationService: NotificationService\n) {\n  import scala.concurrent.ExecutionContext.Implicits.global\n  \n  def placeOrder(userId: String, items: List[OrderItem]): Future[Either[String, Order]] = {\n    if (items.isEmpty) {\n      return Future.successful(Left("Order must contain at least one item"))\n    }\n    \n    repository.findActiveCartByUser(userId).flatMap {\n      case None => \n        Future.successful(Left("No active cart found"))\n      case Some(cart) =>\n        if (cart.items.isEmpty) {\n          Future.successful(Left("Cart is empty"))\n        } else {\n          val order = Order(\n            id = generateOrderId(), \n            userId = userId,\n            items = cart.items,\n            status = "pending",\n            createdAt = Instant.now()\n          )\n          \n          repository.createOrder(order).flatMap { createdOrder =>\n            paymentService.processPayment(userId, calculateTotal(cart.items)).flatMap {\n              case Right(paymentId) =>\n                val finalOrder = createdOrder.copy(\n                  paymentId = Some(paymentId),\n                  status = "paid"\n                )\n                repository.updateOrder(finalOrder).flatMap { updatedOrder =>\n                  notificationService.sendOrderConfirmation(updatedOrder)\n                    .map(_ => Right(updatedOrder))\n                }\n              case Left(error) =>\n                Future.successful(Left(s"Payment failed: $error"))\n            }\n          }\n        }\n    }\n  }\n  \n  private def calculateTotal(items: List[OrderItem]): BigDecimal = \n    items.map(item => item.price * item.quantity).sum\n    \n  private def generateOrderId(): String = \n    s"ORD-${System.currentTimeMillis()}"\n}\n')),(0,a.yg)("h3",{id:"after-2"},"After:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},'sealed trait OrderResult\nobject OrderResult {\n  case class Success(order: Order) extends OrderResult\n  case object EmptyItems extends OrderResult\n  case object NoActiveCart extends OrderResult\n  case object EmptyCart extends OrderResult\n  case class PaymentFailed(reason: String) extends OrderResult\n}\n\nclass OrderService(\n  repository: OrderRepository,\n  paymentService: PaymentService,\n  notificationService: NotificationService\n) {\n  import scala.concurrent.ExecutionContext.Implicits.global\n  import pl.iterators.sealedmonad.syntax._\n  \n  def placeOrder(userId: String, items: List[OrderItem]): Future[OrderResult] = {\n    (for {\n      // Validate items\n      _ <- items.pure[Future]\n          .ensure(_.nonEmpty, OrderResult.EmptyItems)\n      \n      // Find active cart\n      cart <- repository.findActiveCartByUser(userId)\n               .valueOr[OrderResult](OrderResult.NoActiveCart)\n      \n      // Validate cart items\n      _ <- cart.pure[Future]\n          .ensure(_.items.nonEmpty, OrderResult.EmptyCart)\n      \n      // Create order\n      order = Order(\n        id = generateOrderId(),\n        userId = userId,\n        items = cart.items,\n        status = "pending",\n        createdAt = Instant.now()\n      )\n      \n      // Save order\n      createdOrder <- repository.createOrder(order).seal\n      \n      // Process payment\n      paymentId <- paymentService.processPayment(userId, calculateTotal(cart.items))\n                    .attempt {\n                      case Right(id) => Right(id)\n                      case Left(error) => Left(OrderResult.PaymentFailed(error))\n                    }\n      \n      // Update order with payment info\n      finalOrder = createdOrder.copy(\n        paymentId = Some(paymentId),\n        status = "paid"\n      )\n      \n      // Save updated order\n      updatedOrder <- repository.updateOrder(finalOrder).seal\n      \n      // Send confirmation notification\n      _ <- notificationService.sendOrderConfirmation(updatedOrder).seal\n    } yield OrderResult.Success(updatedOrder)).run\n  }\n  \n  private def calculateTotal(items: List[OrderItem]): BigDecimal = \n    items.map(item => item.price * item.quantity).sum\n    \n  private def generateOrderId(): String = \n    s"ORD-${System.currentTimeMillis()}"\n}\n')),(0,a.yg)("h2",{id:"final-checklist"},"Final Checklist"),(0,a.yg)("p",null,"Before considering a migration complete, ensure you've:"),(0,a.yg)("ul",{className:"contains-task-list"},(0,a.yg)("li",{parentName:"ul",className:"task-list-item"},(0,a.yg)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Imported ",(0,a.yg)("inlineCode",{parentName:"li"},"pl.iterators.sealedmonad.syntax._")," wherever needed"),(0,a.yg)("li",{parentName:"ul",className:"task-list-item"},(0,a.yg)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Replaced all pattern matching with Sealed Monad operators"),(0,a.yg)("li",{parentName:"ul",className:"task-list-item"},(0,a.yg)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Added ",(0,a.yg)("inlineCode",{parentName:"li"},".run")," to execute computations"),(0,a.yg)("li",{parentName:"ul",className:"task-list-item"},(0,a.yg)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Updated tests to verify both success and error paths"),(0,a.yg)("li",{parentName:"ul",className:"task-list-item"},(0,a.yg)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Updated documentation to reflect the new approach"),(0,a.yg)("li",{parentName:"ul",className:"task-list-item"},(0,a.yg)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Reviewed for readability and consistency")),(0,a.yg)("p",null,"With these steps, you should be able to successfully migrate to Sealed Monad and enjoy cleaner, more maintainable error handling in your code."),(0,a.yg)("h2",{id:"migrating-from-eithert"},"Migrating from EitherT"),(0,a.yg)("p",null,"If you're currently using Cats' EitherT, here's how to migrate to Sealed Monad."),(0,a.yg)("h3",{id:"before-3"},"Before:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"def confirmEmail(\n  token: String,\n  findAuthMethod: String => Future[Option[AuthMethod]],\n  findUser: Long => Future[Option[User]],\n  upsertAuthMethod: AuthMethod => Future[Int],\n  issueTokenFor: User => String,\n  confirmMethod: AuthMethod => AuthMethod\n): Future[ConfirmResponse] = {\n  import scala.concurrent.ExecutionContext.Implicits.global\n  import cats.implicits._\n  \n  val userT = for {\n    method <- EitherT.fromOptionF(\n                findAuthMethod(token),\n                ifNone = ConfirmResponse.MethodNotFound\n              )\n    user <- EitherT.fromOptionF(\n              findUser(method.userId),\n              ifNone = ConfirmResponse.UserNotFound\n            )\n  } yield (method, user)\n\n  userT.semiflatMap { case (method, user) =>\n    upsertAuthMethod(confirmMethod(method))\n      .map(_ => ConfirmResponse.Confirmed(issueTokenFor(user)))\n  }.merge\n}\n")),(0,a.yg)("h3",{id:"migration-steps-2"},"Migration Steps:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Import the Sealed Monad syntax"),": Add the import at the top of your file.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"import pl.iterators.sealedmonad.syntax._\n")),(0,a.yg)("ol",{start:2},(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Replace EitherT operations with Sealed Monad equivalents"),":"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"EitherT.fromOptionF(opt, ifNone)")," \u2192 ",(0,a.yg)("inlineCode",{parentName:"li"},"opt.valueOr(ifNone)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"EitherT.cond(test, right, left)")," \u2192 ",(0,a.yg)("inlineCode",{parentName:"li"},"right.pure[F].ensure(_ => test, left)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"eitherT.semiflatMap")," \u2192 ",(0,a.yg)("inlineCode",{parentName:"li"},"sealed.flatMap")," or ",(0,a.yg)("inlineCode",{parentName:"li"},"sealed.flatTap")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},".merge")," \u2192 ",(0,a.yg)("inlineCode",{parentName:"li"},".run")))),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Structure as a for-comprehension"),": Put the steps in a for-comprehension.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Add the .run call"),": Complete the computation with ",(0,a.yg)("inlineCode",{parentName:"p"},".run"),"."))),(0,a.yg)("h3",{id:"after-3"},"After:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-scala"},"def confirmEmail(\n  token: String,\n  findAuthMethod: String => Future[Option[AuthMethod]],\n  findUser: Long => Future[Option[User]],\n  upsertAuthMethod: AuthMethod => Future[Int],\n  issueTokenFor: User => String,\n  confirmMethod: AuthMethod => AuthMethod\n): Future[ConfirmResponse] = {\n  import scala.concurrent.ExecutionContext.Implicits.global\n  import pl.iterators.sealedmonad.syntax._\n  \n  (for {\n    method <- findAuthMethod(token)\n              .valueOr[ConfirmResponse](ConfirmResponse.MethodNotFound)\n\n    user <- findUser(method.userId)\n            .valueOr[ConfirmResponse](ConfirmResponse.UserNotFound)\n\n    _ <- upsertAuthMethod(confirmMethod(method)).seal\n  } yield ConfirmResponse.Confirmed(issueTokenFor(user))).run\n}\n")))}c.isMDXComponent=!0},5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>g});var r=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=d(n),m=a,g=u["".concat(l,".").concat(m)]||u[m]||c[m]||i;return n?r.createElement(g,o(o({ref:t},p),{},{components:n})):r.createElement(g,o({ref:t},p))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var d=2;d<i;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);